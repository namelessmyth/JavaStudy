# Docker

## 参考说明

本文内容主要来源于马士兵视频教程（[容器管理工具 Docker](https://www.mashibing.com/study?courseNo=1174&sectionNo=45147&systemId=1&courseVersionId=1783)），结合了老师的讲课内容以及自己的实践做了一些修改。



## 应用程序部署痛点

### 部署流程

案例：将一个开发好的JavaWeb程序部署到用户环境中

安装配置Java运行环境，JDK或JRE

安装配置中间件，例如：Tomcat。

将程序的war包，部署到中间件中。

在服务器上启动tomcat。

首次安装，还需要安装数据库和以及其他中间件（例如：Redis，MQ等）

在集群或者分布式环境下，上述每个节点都可能存在多个节点。



### 应用程序扩容缩容

上述所有服务器都可能涉及扩容和缩容。同样的步骤又得重新实施一遍。



### 应用程序多环境部署

环境：开发环境，测试环境，UAT环境，正式环境。

本地开发环境没问题，上测试有问题。或者测试没问题，上正式又出现问题。然后需要花时间分析原因。

需求：一次成功，可到处运行。



## 计算资源应用演进

### 使用物理服务器的痛点



## 容器底层-Linux关键技术

### 1. 容器技术的前世今生

#### 1979年 — chroot

- 容器技术的概念可以追溯到1979年的UNIX chroot。
- 它是一套“UNIX操作系统”系统，旨在将其root目录及其它子目录变更至文件系统内的新位置，且只接受特定进程的访问。
- 这项功能的设计目的在于为每个进程提供一套隔离化磁盘空间。
- 1982年其被添加至BSD当中。

#### 2000年 — FreeBSD Jails

- FreeBSD Jails是由Derrick T. Woolworth于2000年在FreeBSD研发协会中构建而成的早期容器技术之一。
- 这是一套“操作系统”系统，与chroot的定位类似，不过其中包含有其它进程沙箱机制以对文件系统、用户及网络等资源进行隔离。
- 通过这种方式，它能够为每个Jail、定制化软件安装包乃至配置方案等提供一个对应的IP地址。

#### 2001年 — Linux VServer

- Linux VServer属于另一种jail机制，其能够被用于保护计算机系统之上各分区资源的安全(包括文件系统、CPU时间、网络地址以及内存等)。
- 每个分区被称为一套安全背景(security context)，而其中的虚拟化系统则被称为一套虚拟私有服务器。

#### 2004年 — Solaris容器

- Solaris容器诞生之时面向x86与SPARC系统架构，其最初亮相于2004年2月的Solaris 10 Build 51 beta当中，随后于2005年正式登陆Solaris 10的完整版本。
- Solaris容器相当于将系统资源控制与由分区提供的边界加以结合。各分区立足于单一操作系统实例之内以完全隔离的虚拟服务器形式运行。

#### 2005年 — OpenVZ

- OpenVZ与Solaris容器非常相似，且使用安装有补丁的Linux内核以实现虚拟化、隔离能力、资源管理以及检查点交付。
- 每套OpenVZ容器拥有一套隔离化文件系统、用户与用户群组、一套进程树、网络、设备以及IPC对象。

#### 2006年 — Process容器

- Process容器于2006年由谷歌公司推出，旨在对一整套进程集合中的资源使用量(包括CPU、内存、磁盘I/O以及网络等等)加以限制、分配与隔离。
- 此后其被更名为Control Groups(即控制组)，从而避免其中的“容器”字眼与Linux内核2.6.24中的另一术语出现冲突。这表明了谷歌公司率先重视容器技术的敏锐眼光以及为其做出的突出贡献。

#### 2007年 — Control Groups

Control Groups也就是谷歌实现的cgroups，其于2007年被添加至Linux内核当中。

#### 2008年 — LXC

- LXC指代的是Linux Containers
- 是第一套完整的Linux容器管理实现方案。
- 其功能通过cgroups以及Linux namespaces实现。
- LXC通过liblxc库进行交付，并提供可与Python3、Python2、Lua、Go、Ruby以及Haskell等语言相对接的API。
- 相较于其它容器技术，LXC能够在无需任何额外补丁的前提下运行在原版Linux内核之上。

#### 2011年 — Warden

- Warden由CloudFoundry公司于2011年所建立，其利用LXC作为初始阶段，随后又将其替换为自家实现方案。
- 与LXC不同，Warden并不会与Linux紧密耦合。相反，其能够运行在任意能够提供多种隔离环境方式的操作系统之上。Warden以后台进程方式运行并提供API以实现容器管理。

#### 2013年 — LMCTFY

- Lmctfy代表的是“Let Me Contain That For You(帮你实现容器化)”。它其实属于谷歌容器技术堆栈的开源版本，负责提供Linux应用程序容器。谷歌公司在该项目的起步阶段宣称其能够提供值得信赖的性能表现、高资源利用率、共享资源机制、充裕的发展空间以及趋近于零的额外资源消耗。
- 2013年10月lmctfy的首个版本正式推出，谷歌公司在2015年决定将lmctfy的核心概念与抽象机制转化为libcontainer。在失去了主干之后，如今lmctfy已经失去一切积极的发展势头。

　　Libcontainer项目最初由Docker公司建立，如今已经被归入开放容器基金会的管辖范畴。

#### 2013年-Docker

- 在2013年Docker刚发布的时候，它是一款基于LXC的开源容器管理引擎。
- 把LXC复杂的容器创建与使用方式简化为Docker自己的一套命令体系。
- 随着Docker的不断发展，它开始有了更为远大的目标，那就是反向定义容器的实现标准，将底层实现都抽象化到Libcontainer的接口。这就意味着，底层容器的实现方式变成了一种可变的方案，无论是使用namespace、cgroups技术抑或是使用systemd等其他方案，只要实现了Libcontainer定义的一组接口，Docker都可以运行。这也为Docker实现全面的跨平台带来了可能。



### 2. NameSpace

#### 2.1 NameSpace介绍

- 很多编程语言都包含了命名空间的概念，我们可以认为命名空间是一种封装，封装本身实际上实现了代码的隔离


- 在操作系统中命名空间命名空间提供的是系统资源的隔离，其中系统资源包括了：进程、网络、文件系统......


- 实际上linux系统实现命名空间主要目的之一就是为了实现轻量级虚拟化服务，也就是我们说的容器，在同一个命名空间下的进程可以感知彼此的变化，而对其他命名空间的进程一无所知，这样就可以让容器中的进程产生一个错觉，仿佛它自己置身于一个独立的系统环境当中，以此达到独立和隔离的目的。



#### 2.2 Linux系统中NameSpace分类



|   命名空间   |             描述             |                             作用                             |                             备注                             |
| :----------: | :--------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 进程命名空间 |          隔离进程ID          | Linux通过命名空间管理进程号，同一个进程，在不同的命名空间进程号不同 |       进程命名空间是一个父子结构，子空间对于父空间可见       |
| 网络命名空间 | 隔离网络设备、协议栈、端口等 |                通过网络命名空间，实现网络隔离                |  docker采用虚拟网络设备，将不同命名空间的网络设备连接到一起  |
| IPC命名空间  |        隔离进程间通信        |                        进程间交互方法                        | PID命名空间和IPC命名空间可以组合起来用，同一个IPC名字空间内的进程可以彼此看见，允许进行交互，不同空间进程无法交互 |
| 挂载命名空间 |          隔离挂载点          |                         隔离文件目录                         | 进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能，而在安全性方面比 chroot 更高 |
| UTS命名空间  |    隔离Hostname和NIS域名     | 让容器拥有独立的主机名和域名，从而让容器看起来像个独立的主机 |           目的是独立出主机名和网络信息服务（NIS）            |
| 用户命名空间 |      隔离用户和group ID      |        每个容器内上的用户跟宿主主机上不在一个命名空间        | 同进程 ID 一样，用户 ID 和组 ID 在命名空间内外是不一样的，并且在不同命名空间内可以存在相同的 ID |







#### 2.3 NameSpace应用案例

> 以net namespace为例



- 在 Linux 中，网络命名空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络命名空间经常用来隔离网络设备和服务，只有拥有同样网络命名空间的设备，才能看到彼此。
- 从逻辑上说，网络命名空间是网络栈的副本，拥有自己的网络设备、路由选择表、邻接表、Netfilter表、网络套接字、网络procfs条目、网络sysfs条目和其他网络资源。
- 从系统的角度来看，当通过clone()系统调用创建新进程时，传递标志CLONE_NEWNET将在新进程中创建一个全新的网络命名空间。
- 从用户的角度来看，我们只需使用工具ip（package is iproute2）来创建一个新的持久网络命名空间。





![image-20220111132707215](沈俊杰-马士兵-云原生.assets/image-20220111132707215.png)



##### 2.3.1 创建net命名空间



~~~powershell
创建名称为msb的网络命名空间
# ip netns add msb
~~~



~~~powershell
查看已创建的网络命名空间
# ip netns ls
msb
~~~





##### 2.3.2 删除net命名空间



~~~powershell
删除已创建的网络命名空间
# ip netns delete msb
~~~



##### 2.3.3 在net命名空间中执行命令



~~~powershell
在网络命名空间中执行bash命令，如果想退出，需要使用exit
# ip netns exec msb bash
~~~



##### 2.3.4 在net命令空间中执行查看网络连接(网卡)命令



~~~powershell
在网络命名空间中查看网络命名空间中的网卡信息
# ip link
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
~~~





~~~powershell
在Linux主机系统中查看
# ip netns exec msb ip link list
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
~~~





##### 2.3.5 退出当前的net命名空间



~~~powershell
退出已进入的网络命名空间
# exit
exit
~~~



##### 2.3.6 在net命名空间中执行多条命令



~~~powershell
在网络命名空间中查看路由表
# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
~~~



~~~powershell
在网络命名空间中查看防火墙规则
# iptables -t nat -nL
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
~~~



##### 2.3.7 创建虚拟网卡

> 同时创建一对虚拟网卡



~~~powershell
创建虚拟网卡对
# ip link add veth0 type veth peer name veth1
~~~



~~~powershell
在物理机上查看
# ip a s
......
10: veth1@veth0: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether de:44:f8:b7:12:65 brd ff:ff:ff:ff:ff:ff
11: veth0@veth1: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 46:5e:89:8c:cb:b3 brd ff:ff:ff:ff:ff:ff
~~~



##### 2.3.8 迁移虚拟网卡到命名空间中

>这两个网卡还都属于“default”或“global”命名空间，和物理网卡一样。把其中一个网卡转移到命名空间msb中。



~~~powershell
把创建的veth1网卡添加到msb网络命名空间中
# ip link set veth1 netns msb
~~~



~~~powershell
在Linux系统命令行查看网络命名空间中的网络
# ip netns exec msb ip link
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
10: veth1@if11: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether de:44:f8:b7:12:65 brd ff:ff:ff:ff:ff:ff link-netnsid 0
~~~



##### 2.3.9 命名空间中迁出虚拟网卡



~~~powershell
在Linux系统命令行把虚拟网卡veth1从网络命名空间删除
# ip netns exec msb ip link delete veth1
~~~



~~~powershell
在Linux系统命令行查看结果
# ip netns exec msb ip link
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
~~~



##### 2.3.10 配置虚拟网卡IP地址



~~~powershell
再次创建虚拟网卡，添加到msb网络命名空间，并设置IP地址
# ip link add veth0 type veth peer name veth1
# ip link set veth1 netns msb
# ip netns exec msb ip addr add 192.168.50.2/24 dev veth1
~~~



~~~powershell
在Linux系统命令行查看网络状态
# ip netns exec msb ip addr
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
12: veth1@if13: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether fe:20:ac:a8:13:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.50.2/24 scope global veth1
       valid_lft forever preferred_lft forever
~~~



~~~powershell
启动虚拟网卡,veth1与lo全部要启动
# ip netns exec msb ip link set veth1 up

# ip netns exec msb ip link set lo up
~~~







~~~powershell
为物理机veth0添加IP地址

# ip a s
......
15: veth0@if14: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group defau
lt qlen 1000
    link/ether 2e:b4:40:c8:73:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0
~~~



~~~powershell
# ip addr add 192.168.50.3/24 dev veth0

# ip a s veth0
15: veth0@if14: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 2e:b4:40:c8:73:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.50.3/24 scope global veth0
       valid_lft forever preferred_lft forever
~~~



~~~powershell
# ip link set veth0 up
~~~



~~~powershell
在宿主机上ping msb中的veth1
# ping 192.168.50.2
PING 192.168.50.2 (192.168.50.2) 56(84) bytes of data.
64 bytes from 192.168.50.2: icmp_seq=1 ttl=64 time=0.102 ms
64 bytes from 192.168.50.2: icmp_seq=2 ttl=64 time=0.068 ms
64 bytes from 192.168.50.2: icmp_seq=3 ttl=64 time=0.068 ms
~~~



~~~powershell
在msb中的veth1 ping 宿主机上veth0
# ip netns exec msb ping 192.168.50.3
PING 192.168.50.3 (192.168.50.3) 56(84) bytes of data.
64 bytes from 192.168.50.3: icmp_seq=1 ttl=64 time=0.053 ms
64 bytes from 192.168.50.3: icmp_seq=2 ttl=64 time=0.031 ms
64 bytes from 192.168.50.3: icmp_seq=3 ttl=64 time=0.029 ms
~~~



~~~powershell
如果需要访问本机的其它网段，可手动添加如下默认路由条目。
# ip netns exec msb ip route add default via 192.168.50.3
~~~





> 关于如何ping通外网主机，可设置路由转发完成。





### 3. CGroups

#### 3.1 CGroups介绍

- Control groups(cgroups) 控制组


- linux内核提供的可以限制、记录、隔离进程组所使用的物理资源的机制。为容器而生，没有cgroups就没有今天的容器技术。



![image-20220112182824405](沈俊杰-马士兵-云原生.assets/image-20220112182824405.png)





#### 3.2 CGroups功能

- 资源限制（Resource Limitation）：cgroups 可以对进程组使用的资源总额进行限制。如设定应用运行时使用内存的上限，一旦超过这个配额就发出 OOM（Out of Memory）。
- 优先级分配（Prioritization）：通过分配的 CPU 时间片数量及硬盘 IO 带宽大小，实际上就相当于控制了进程运行的优先级。
- 资源统计（Accounting）： cgroups 可以统计系统的资源使用量，如 CPU 使用时长、内存用量等等，这个功能非常适用于计费。
- 进程控制（Control）：cgroups 可以对进程组执行挂起、恢复等操作。



#### 3.3 CGroups应用案例



##### 3.3.1 安装及开启服务



~~~shell
[root@localhost ~]# yum -y install libcgroup
[root@localhost ~]# systemctl start cgconfig.service 	
[root@localhost ~]# systemctl enable cgconfig.service
~~~



##### 3.3.2 限制进程使用CPU

###### 3.3.2.1 查看cpu shares

~~~powershell
查看资源限制子系统
[root@localhost ~]# lssubsys
cpuset
cpu,cpuacct
memory
devices
freezer
net_cls,net_prio
blkio
perf_event
hugetlb
pids

查看子系统配置文件所在位置
[root@localhost ~]# ls /sys/fs/cgroup/
blkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  systemd
cpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids
[root@localhost ~]# ls /sys/fs/cgroup/cpu
cgroup.clone_children  cpuacct.stat          cpu.cfs_quota_us   cpu.stat
cgroup.event_control   cpuacct.usage         cpu.rt_period_us   notify_on_release
cgroup.procs           cpuacct.usage_percpu  cpu.rt_runtime_us  release_agent
cgroup.sane_behavior   cpu.cfs_period_us     cpu.shares         tasks

查看CPU时间分片，用于保证分组所得到的CPU分片总量。
[root@localhost ~]# cat /sys/fs/cgroup/cpu/cpu.shares
1024
~~~





###### 3.3.2.2 使用CPU子系统创建2个group分组

~~~shell
[root@localhost ~]# vim /etc/cgconfig.conf
group lesscpu {
	cpu{
		cpu.shares=200;
	}	
}
group morecpu {
	cpu{
		cpu.shares=800;
	}	
}

[root@localhost ~]# systemctl restart cgconfig
~~~

准备一个脚本

~~~powershell
#!/bin/bash

a=1
while true
do

        a=$[$a+1]
done

~~~



将将要运行的应用程序分配到指定分组(**请使用单CPU机器,三个终端验证**)

~~~shell
终端1# cgexec -g cpu:lesscpu sh /tmp/1.sh

终端2# cgexec -g cpu:morecpu sh /tmp/1.sh

终端3# top
~~~



**PS: 如果主机有多CPU，为了验证效果，可以进行如下操作**

~~~shell
# lscpu
# echo 0 > /sys/devices/system/cpu/cpu0/online
# echo 1 > /sys/devices/system/cpu/cpu1/online
~~~



## Docker安装部署

容器管理工具 Docker生态架构及部署

### 1. Docker生态架构

#### 1.1 Docker Containers Are Everywhere

Docker可以安装部署在如下地方

![image-20220118165726624](沈俊杰-马士兵-云原生.assets/image-20220118165726624.png)



#### 1.2 生态架构

![image-20220118170228476](沈俊杰-马士兵-云原生.assets/image-20220118170228476.png)



##### 1.2.1 Docker Host

用于安装Docker daemon的主机，即为Docker Host，并且该主机中可基于容器镜像运行容器。



##### 1.2.2 Docker daemon

用于管理Docker Host中运行的容器、容器镜像、容器网络等，管理由Containerd.io提供的容器。



##### 1.2.3 Registry

容器镜像仓库，用于存储已生成容器运行模板的仓库，用户使用时，可直接从容器镜像仓库中下载容器镜像，即容器运行模板，就可以运行容器镜像中包含的应用了。例如：Docker Hub,也可以使用Harbor实现企业私有的容器镜像仓库。



##### 1.2.4 Docker client

Docker Daemon客户端工具，用于同Docker Daemon进行通信，执行用户指令，可部署在Docker Host上，也可以部署在其它主机，能够连接到Docker Daemon即可操作。



##### 1.2.5 Image

把应用运行环境及计算资源打包方式生成可再用于启动容器的不可变的基础设施的模板文件，主要用于基于其启动一个容器。



##### 1.2.6 Container

由容器镜像生成，用于应用程序运行的环境，包含容器镜像中所有文件及用户后添加的文件，属于基于容器镜像生成的可读写层，这也是应用程序活跃的空间。



##### 1.2.7 Docker Dashboard

> 仅限于MAC与Windows操作系统上安装使用。

Docker Dashboard 提供了一个简单的界面，使您能够直接从您的机器管理您的容器、应用程序和映像，而无需使用 CLI 来执行核心操作。



![image-20220118185507047](沈俊杰-马士兵-云原生.assets/image-20220118185507047.png)





#### 1.3 Docker版本

- Docker-ce Docker社区版，主要用于个人开发者测试使用，免费版本
- Docker-ee Docker企业版，主要用于为企业开发及应用部署使用，收费版本，免费试用一个月，2020年因国际政治原因曾一度限制中国企业使用。



### 2. Docker部署

> 本文主要介绍的是：安装Docker-ce版本。
>
> 前提：
>
> 在Vmware虚拟机中已安装好CentOS 7.9。且虚拟机可以通过ssh访问。
>
> 登录linux后，执行firewall-cmd --state确认防火墙已关闭。
>
> 执行iptables -nL，继续确认网络。
>
> 执行sestatus确保selinux为disable状态

#### 2.1 使用YUM源部署

> YUM源可以使用官方YUM源、清华大学开源镜像站配置YUM源，也可以使用阿里云开源镜像站提供的YUM源，建议选择使用阿里云开源镜像站提供的YUM源，原因速度快。



##### 2.1.1 获取阿里云开源镜像站YUM源文件

可以直接访问这个网址：https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.4c9b1b119z027O，如果网址失效，可以在百度上搜索关键字：“阿里云开源镜像站”。

在打开的网站上找到如下图中的地址

![image-20220118182432607](沈俊杰-马士兵-云原生.assets/image-20220118182432607.png)

在Linux中执行如下命令：

~~~shell
在docker host上使用 wget下载到/etc/yum.repos.d目录中即可。
# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

以下是执行结果：
--2023-08-29 23:13:40--  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
正在解析主机 mirrors.aliyun.com (mirrors.aliyun.com)... 27.128.223.241, 221.230.245.103, 120.39.195.185, ...
正在连接 mirrors.aliyun.com (mirrors.aliyun.com)|27.128.223.241|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：2081 (2.0K) [application/octet-stream]
正在保存至: “/etc/yum.repos.d/docker-ce.repo”

100%[===========================================================================================================================>] 2,081       --.-K/s 用时 0s      

2023-08-29 23:13:40 (1000 MB/s) - 已保存 “/etc/yum.repos.d/docker-ce.repo” [2081/2081])

查看当前主机yum源
[root@~]# yum repolist
~~~

执行命令yum repolist，如果看到关键字docker-ce-stable，代表可用。

![image-20220118182749037](沈俊杰-马士兵-云原生.assets/image-20220118182749037.png)



##### 2.1.2 安装Docker-ce

在docker host上安装即可，本次使用YUM源中稳定版本，由于版本在不断更新，不同的时间安装版本也不相同，使用方法基本一致。

~~~shell
直接安装docker-ce，此为docker daemon，所有依赖将被yum自动安装，含docker client等。
# yum -y install docker-ce
~~~



![image-20220118183627705](沈俊杰-马士兵-云原生.assets/image-20220118183627705.png)



##### 2.1.3 配置Docker Daemon启动文件

由于Docker使用过程中会对Centos操作系统中的Iptables防火墙中的FORWARD链默认规划产生影响及需要让Docker Daemon接受用户自定义的daemon.json文件，需要要按使用者要求的方式修改。

~~~powershell
# vi /usr/lib/systemd/system/docker.service
~~~

具体操作见下图，删除这个部分：” -H fd:// --containerd=/run/containerd/containerd.sock“

新增这个部分：”ExecStartPost=/sbin/iptables -P FORWARD ACCEPT”

![image-20230830171428848](沈俊杰-马士兵-云原生.assets/image-20230830171428848.png)



##### 2.1.4 启动Docker服务并查看已安装版本

~~~shell
重启加载daemon文件（也可以直接执行下面的命令，报错在执行这个）
# systemctl daemon-reload

启动docker daemon
# systemctl start docker

设置开机自启动
# systemctl enable docker
~~~



~~~shell
使用docker version客户端命令查看已安装docker软件版本
# docker version
Client: Docker Engine - Community 客户端
 Version:           20.10.12
 API version:       1.41
 Go version:        go1.16.12
 Git commit:        e91ed57
 Built:             Mon Dec 13 11:45:41 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community Docker管理引擎
 Engine:
  Version:          20.10.12
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.16.12
  Git commit:       459d0df
  Built:            Mon Dec 13 11:44:05 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.12
  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d
 runc:
  Version:          1.0.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
~~~



2.1.5 卸载docker

```sh
停止docker服务
# systemctl stop docker
使用yum命令卸载docker组件
# yum remove docker-ce containerd.io docker-ce-cli
```

更详细的卸载方法详见[官方文档](https://docs.docker.com/engine/install/centos/)。



#### 2.2 使用二进制文件部署

> 官方不建议此种部署方式，主要因为不能自动更新，在条件有限制的情况下才使用。

二进制安装参考网址：https://docs.docker.com/engine/install/binaries/

![image-20220118190327846](沈俊杰-马士兵-云原生.assets/image-20220118190327846.png)



[二进制安装包下载地址](https://download.docker.com/linux/static/stable/?_gl=1*1sa56vl*_ga*MTkyNzYxMzA3Mi4xNjkzMzg4NjM1*_ga_XJWPQMJYHQ*MTY5MzM5MTQwNy4yLjEuMTY5MzM5MTQxMy41NC4wLjA.)，打开后，根据uname -r命令结果，来选择对应的内核版本，一般会选x86_64

![image-20220118190507974](沈俊杰-马士兵-云原生.assets/image-20220118190507974.png)

根据时间选择最新版本，本文用的是：docker-24.0.5.tgz。

找到后，如果不想用浏览器自带的下载工具下载，可以复制链接，然后在linux中使用wget下载。也可以用第三方下载工具下载，下载完了在传到linux里面。

~~~shell
获取二进制文件，此文件中包含dockerd与docker 2个文件。
# wget https://download.docker.com/linux/static/stable/x86_64/docker-24.0.5.tgz

下载完毕之后，解压下载的文件
# tar xf docker-24.0.5.tgz
查看解压出的目录，docker
# ls docker
containerd       containerd-shim-runc-v2  docker   docker-init   runc
containerd-shim  ctr                      dockerd  docker-proxy

安装解压后的所有二进制文件
# cp docker/* /usr/bin/

运行Daemon
# dockerd &

回车后会有大量的信息输出，停止后，直接回车即可使用。
如果您需要使用其他选项启动守护程序，请相应地修改上述命令或创建并编辑文件`/etc/docker/daemon.json` 以添加自定义配置选项。

确认是否可以使用docker客户端命令
# which docker
/usr/bin/docker

使用二进制安装的docker客户端
# docker version
Client:
 Version:           24.0.5
 ......
~~~



### 3. 使用docker运行Nginx

#### 3.1 部署Nginx

##### 3.1.1 观察下载容器镜像过程

> 查找本地容器镜像文件

~~~powershell
docker run 执行应用，nginx为应用的模板名字，:latest为最新版，-d为后台运行
# docker run -d nginx:latest
先从本地找，本地找不到去网上下载
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
a2abf6c4d29d: Downloading  1.966MB/31.36MB 下载中
a9edb18cadd1: Downloading  1.572MB/25.35MB
589b7251471a: Download complete 下载完成
186b1aaa4aa6: Download complete
b4df32aa5a72: Waiting 等待下载
a0bcbecc962e: Waiting
下载并安装完成
Status: Downloaded newer image for nginx:latest
应用id
51bbe4e8ffd543082e64a4878cb69e48ee45dee290e15204dad2c6b5f889ce6e
~~~

```powershell
命令解释
docker run 启动一个容器
-d 把容器镜像中需要执行的命令以daemon（守护进程）的方式运行
nginx 应用容器镜像的名称，通常表示该镜像为某一个软件
latest 表示上述容器镜像的版本，表示最新版本，用户可自定义其标识，例如v1或v2等
```



##### 3.1.2 观察容器运行情况

~~~powershell
# docker ps
CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS        PORTS     NAMES
9834c8c18a7c   nginx:latest "/docker-entrypoint.…"   24 seconds ago   Up 23 seconds 80/tcp condescending_pare
~~~

[docker ps 命令说明](#2.3.2 docker ps)



#### 3.2 访问容器中Nginx服务

##### 3.2.1 确认容器IP地址

实际工作中不需要此步操作。

~~~powershell
命令解释
docker inspect 为查看容器结构信息命令，后面的id通过docker ps命令获得。
9834 为前面生成的容器ID号前4位，使用这个ID号时，由于其较长，使用时能最短识别即可。
~~~

~~~powershell
 # docker inspect 9834
 
 "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2", 容器IP地址
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "d3de2fdbc30ee36a55c1431ef3ae4578392e552009f00b2019b4720735fe5a60",
                    "EndpointID": "d91f47c9f756ff22dc599a207164f2e9366bd0c530882ce0f08ae2278fb3d50c",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",   容器IP地址
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
~~~



##### 3.2.2 容器网络说明



![image-20220121172037253](沈俊杰-马士兵-云原生.assets/image-20220121172037253.png)



~~~powershell
# ip a s
......
docker0网桥，用于为容器提供桥接，转发到主机之外的网络
5: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:d5:c3:d4:cc brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:d5ff:fec3:d4cc/64 scope link
       valid_lft forever preferred_lft forever
       
       
与容器中的虚拟网络设备在同一个命名空间中，用于把容器中的网络连接到主机
9: veth393dece@if8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default
    link/ether 02:e3:11:58:54:0f brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::e3:11ff:fe58:540f/64 scope link
       valid_lft forever preferred_lft forever
~~~



##### 3.2.3 使用curl命令访问

~~~powershell
# curl http://172.17.0.2

返回结果，表示访问成功！
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
~~~



## Docker命令

### 帮助

#### Docker命令获取帮助方法

~~~powershell
# docker -h
Flag shorthand -h has been deprecated, please use --help

Usage:  docker [OPTIONS] COMMAND  用法

A self-sufficient runtime for containers 功能介绍

Options: 选项
      --config string      Location of client config files (default "/root/.docker")
  -c, --context string     Name of the context to use to connect to the daemon (overrides
                           DOCKER_HOST env var and default context set with "docker context use")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal")
                           (default "info")
...
查看某个命令的帮助
# docker run --help

Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
Create and run a new container from an image
Aliases:
  docker container run, docker run

Options:
      --add-host list                  Add a custom host-to-IP mapping (host:ip)
      --annotation map                 Add an annotation to the container (passed through to the OCI runtime) (default map[])
...

~~~



#### Docker官网提供的命令说明

网址链接：https://docs.docker.com/engine/reference/commandline/run/

![image-20220121173705508](沈俊杰-马士兵-云原生.assets/image-20220121173705508.png)



### docker命令应用

#### 2.3.1 docker run

~~~powershell
命令解释
docker run 运行一个命令在容器中，命令是主体，没有命令容器就会消亡
-i 交互式
-t 提供终端
--name c1 把将运行的容器命名为c1
centos:latest 使用centos最新版本容器镜像
bash 在容器中执行的命令
~~~

~~~powershell
# docker run -i -t --name c1 centos:latest bash
...

下载并安装完镜像后，直接进入容器中的命令行
[root@948f234e22a1 /]#

查看主机名
[root@948f234e22a1 /]# hostname
948f234e22a1

查看网络信息
[root@948f234e22a1 /]# ip a s
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
12: eth0@if13: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

查看进程
[root@948f234e22a1 /]# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.1  12036  2172 pts/0    Ss   09:58   0:00 bash
root         16  0.0  0.0  44652  1784 pts/0    R+   10:02   0:00 ps aux

查看用户
[root@948f234e22a1 /]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
systemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin
systemd-resolve:x:193:193:systemd Resolver:/:/sbin/nologin

查看当前目录
[root@948f234e22a1 /]# pwd
/

查看根目录，每个容器拥有自己独立的文件系统
[root@948f234e22a1 /]# ls
bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr

退出bash命令执行，观察容器运行情况
[root@948f234e22a1 /]# exit
exit
[root@localhost ~]#
~~~



#### 2.3.2 docker ps

**命令解释**
docker ps 查看正在运行的容器，本案例由于没有命令在容器中运行，因此容器被停止了，所以本次查看没有结果。

docker ps --all 可以查看正在运行的和停止运行的容器

~~~powershell
# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

# docker ps --all
CONTAINER ID   IMAGE           COMMAND     CREATED             STATUS                         PORTS     NAMES
948f234e22a1   centos:latest   "bash"    10 minutes ago      Exited (0) 2 minutes ago                    c1
~~~

**输出内容解释**

| CONTAINERID  | IMAGE        | COMMAND                | CREATED        | STATUS        | PORTS  | NAMES              |
| ------------ | ------------ | ---------------------- | -------------- | ------------- | ------ | ------------------ |
| 容器ID       | 容器镜像名   | 容器中运行的命令       | 创建时间       | 状态          | 端口   | 容器名称           |
| 9834c8c18a7c | nginx:latest | "/docker-entrypoint.…" | 24 seconds ago | Up 23 seconds | 80/tcp | condescending_pare |



#### 2.3.3 docker inspect

**命令解释**
docker inpect 查看容器详细信息

操作说明
在上述提示符处按住ctrl键，再按p键与q键，可以退出交互式的容器，容器会处于运行状态。

~~~powershell
# docker run -it --name c2 centos:latest bash
[root@9f2eea16da4c /]# 

# docker ps
CONTAINER ID   IMAGE           COMMAND   CREATED          STATUS          PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"    37 seconds ago   Up 35 seconds             c2

# docker inspect c2

"Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "d3de2fdbc30ee36a55c1431ef3ae4578392e552009f00b2019b4720735fe5a60",
                    "EndpointID": "d1a2b7609f2f73a6cac67229a4395eef293f695c0ac4fd6c9c9e6913c9c85c1c",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
~~~



#### 2.3.4 docker  exec 

~~~powershell
命令解释
docker exec 在容器外实现与容器交互执行某命令
-it 交互式
c2 正在运行的容器名称
ls /root 在正在运行的容器中运行相关的命令
~~~

~~~powershell
让c2容器执行命令 ls /root
# docker exec -it c2 ls /root
anaconda-ks.cfg  anaconda-post.log  original-ks.cfg

下面命令与上面命令执行效果一致
# docker exec c2 ls /root
anaconda-ks.cfg
anaconda-post.log
original-ks.cfg
~~~



#### 2.3.5 docker attach

**命令解释**
docker attach 类似于ssh命令，可以进入到正在运行的容器中
c2 正在运行的容器名称，也可以使用容器id
如果进入的一个容器是无法交互的，则会卡住。

**退出说明**
docker attach 退出容器时，如不需要容器再运行，可直接使用exit退出；如需要容器继续运行，可使用ctrl+p+q


~~~powershell
查看正在运行的容器
# docker ps
CONTAINER ID   IMAGE           COMMAND   CREATED          STATUS          PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"    13 minutes ago   Up 13 minutes             c2

进入c2容器内部
[root@localhost ~]# docker attach c2
[root@9f2eea16da4c /]#
~~~



#### 2.3.6 docker stop

**命令说明**

停止一个正在运行的容器，可以通过docker ps -all查看到。


~~~powershell
# docker ps
CONTAINER ID   IMAGE           COMMAND   CREATED          STATUS          PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"    22 minutes ago   Up 22 minutes             c2

# docker stop 9f2eea16da4c
9f2eea16da4c

# docker ps --all
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS                       PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"                   22 minutes ago   Exited (137) 4 seconds ago  c2
~~~



#### 2.3.7 docker start

**命令解释**

启动一个或多个已经停止的容器。如果容器已经移除则无法启动

~~~powershell
# docker ps --all
CONTAINER ID   IMAGE           COMMAND     CREATED          STATUS                       PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"      22 minutes ago   Exited (137) 4 seconds ago              c2

# docker start 9f2eea
9f2eea

# docker ps
CONTAINER ID   IMAGE           COMMAND   CREATED          STATUS          PORTS     NAMES
9f2eea16da4c   centos:latest   "bash"    24 minutes ago   Up 16 seconds             c2
~~~



#### 2.3.8  docker top

**命令解释**

在Docker Host查看容器中运行的进程信息

docker top 查看container内进程信息，指在docker host上查看，与docker exec -it c2 ps -ef不同。

~~~powershell
# docker top c2
UID    PID     PPID      C      STIME        TTY              TIME                CMD
root  69040   69020      0      18:37       pts/0           00:00:00              bash
~~~

**返回结果说明**

| UID    | PID          | PPID   | C       | STIME    | TTY        | TIME        | CMD        |
| ------ | ------------ | ------ | ------- | -------- | ---------- | ----------- | ---------- |
| 用户id | 容器中进程id | 容器id | cpu占用 | 启动时间 | 所在的终端 | 占用cpu总长 | 执行的命令 |
| root   | 69040        | 69020  | 0       | 18:37    | pts/0      | 00:00:00    | bash       |



#### 2.3.9 docker rm

**命令解释**

如果容器已停止，使用此命令可以直接删除；如果容器处于运行状态，则需要提前关闭容器后，再删除容器。

删除时可以使用容器名称或者id。

```shell
[root@dev-study ~]# docker ps --all
CONTAINER ID   IMAGE          COMMAND                   CREATED       STATUS                     PORTS     NAMES
afce7660b05f   nginx:latest   "/docker-entrypoint.…"   2 hours ago   Exited (0) 9 seconds ago             eloquent_hodgkin
51bbe4e8ffd5   nginx:latest   "/docker-entrypoint.…"   2 hours ago   Up 2 hours                 80/tcp    frosty_hodgkin

[root@dev-study ~]# docker remove 7660
Error response from daemon: No such container: 7660
[root@dev-study ~]# docker remove afce7660b05f
afce7660b05f
[root@dev-study ~]# docker ps -all
CONTAINER ID   IMAGE          COMMAND                   CREATED       STATUS       PORTS     NAMES
51bbe4e8ffd5   nginx:latest   "/docker-entrypoint.…"   3 hours ago   Up 3 hours   80/tcp    frosty_hodgkin
[root@dev-study ~]# 
```

**批量删除容器**

如果存在大量容器需要删除，可以使用管道方式来批量删除

~~~powershell
# docker ps --all
CONTAINER ID   IMAGE           COMMAND          CREATED      STATUS                  PORTS    NAMES
948f234e22a1   centos:latest   "bash"           2 days ago   Exited (0) 2 days ago            c1
01cb3e01273c   centos:latest   "bash"           2 days ago   Exited (0) 2 days ago            systemimage1
46d950fdfb33   nginx:latest    "/docker-ent..." 2 days ago   Exited (0) 2 days ago            upbeat_goldberg

NR>=2代表从第二行开始，print $1 代表只要第一列的容器id
# docker ps --all | awk '{if (NR>=2){print $1}}' | xargs docker rm
~~~









# Devops

